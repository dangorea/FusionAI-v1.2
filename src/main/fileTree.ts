import fs from 'fs';
import path from 'path';

// Maximum file size in bytes (30 MB in this example)
const MAX_FILE_SIZE = 30 * 1024 * 1024;

// Directories to skip â€“ includes many folders generated by common development tools and platforms.
export const SKIP_DIRECTORIES = new Set([
  // Version control and IDE settings
  '.git',
  '.svn',
  '.hg',
  '.idea',
  '.vscode',
  // Package and dependency directories
  'node_modules',
  'bower_components',
  'vendor',
  // Build, distribution, and cache directories
  'build',
  'dist',
  'public',
  '.cache',
  '.parcel-cache',
  'coverage',
  'out',
  '.next',
  '.nuxt',
  'tmp',
  'temp',
  'logs',
  '.logs',
  // Swift / iOS
  'DerivedData',
  'Pods',
  '.xcworkspace',
  '.xcodeproj',
  '.swiftpm',
  // Android
  '.gradle',
  'captures',
  // .NET / C#
  'bin',
  'obj',
  '.vs',
  'packages',
  // Java (Maven/Gradle)
  'target',
  '.mvn',
  // Python
  'env',
  'venv',
  '__pycache__',
  '.pytest_cache',
  // Ruby
  '.bundle',
  'log',
  // C/C++ and others
  'CMakeFiles',
]);

// Files to skip entirely.
const SKIP_FILES = new Set(['.DS_Store']);

// File extensions to skip (allowing only .svg for icons)
const DISALLOWED_EXTENSIONS = new Set([
  'png',
  'jpg',
  'jpeg',
  'gif',
  'bmp',
  'ico',
  'mp4',
  'avi',
  'mov',
  'wmv',
  'flv',
  'mp3',
  'wav',
  'webp',
]);

/**
 * Recursively builds a file tree while skipping:
 * - Unwanted directories (if not the root)
 * - Specific files (e.g. .DS_Store)
 * - Files that exceed the maximum file size.
 * - Files with disallowed media or icon extensions (only .svg files will be allowed).
 *
 * Also sorts each folder's children so that folders appear first (alphabetically) then files.
 *
 * @param dir Path of the directory
 * @param isRoot Whether this is the root folder (default true)
 */
export function getFileTree(dir: string, isRoot = true) {
  const baseName = path.basename(dir);

  if (!isRoot && SKIP_DIRECTORIES.has(baseName)) {
    return null;
  }

  const tree: any = { name: baseName, path: dir, children: [] };

  try {
    const items = fs.readdirSync(dir);
    tree.children = items
      .map((item) => {
        if (SKIP_FILES.has(item)) return null;

        const fullPath = path.join(dir, item);
        try {
          const stat = fs.statSync(fullPath);
          if (stat.isDirectory()) {
            return getFileTree(fullPath, false);
          } else {
            // Skip files that are too large.
            if (stat.size > MAX_FILE_SIZE) {
              return null;
            }
            const ext = path.extname(item).slice(1).toLowerCase();
            if (DISALLOWED_EXTENSIONS.has(ext)) {
              return null;
            }
            return { name: item, path: fullPath };
          }
        } catch (err) {
          console.error('Error reading item:', fullPath, err);
          return null;
        }
      })
      .filter((child) => child !== null);

    tree.children.sort((a: any, b: any) => {
      const aIsFolder = a.children !== undefined;
      const bIsFolder = b.children !== undefined;
      if (aIsFolder && !bIsFolder) return -1;
      if (!aIsFolder && bIsFolder) return 1;
      return a.name.localeCompare(b.name);
    });
  } catch (error) {
    console.error('Error reading directory:', dir, error);
  }

  return tree;
}
