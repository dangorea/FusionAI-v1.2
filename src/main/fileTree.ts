import fs from 'fs';
import path from 'path';

// Declare the FileNode interface used in these functions.
export interface FileNode {
  name: string;
  path: string;
  children?: FileNode[];
  changeType?: 'added' | 'modified' | 'deleted';
}

// Maximum file size in bytes (30 MB in this example)
const MAX_FILE_SIZE = 30 * 1024 * 1024;

// Directories to skip â€“ includes many folders generated by common development tools and platforms.
export const SKIP_DIRECTORIES = new Set([
  // Version control and IDE settings
  '.git',
  '.svn',
  '.hg',
  '.idea',
  '.vscode',
  // Package and dependency directories
  'node_modules',
  'bower_components',
  'vendor',
  // Build, distribution, and cache directories
  'build',
  'dist',
  'public',
  '.cache',
  '.parcel-cache',
  'coverage',
  'out',
  '.next',
  '.nuxt',
  'tmp',
  'temp',
  'logs',
  '.logs',
  // Swift / iOS
  'DerivedData',
  'Pods',
  '.xcworkspace',
  '.xcodeproj',
  '.swiftpm',
  // Android
  '.gradle',
  'captures',
  // .NET / C#
  'bin',
  'obj',
  '.vs',
  'packages',
  // Java (Maven/Gradle)
  'target',
  '.mvn',
  // Python
  'env',
  'venv',
  '__pycache__',
  '.pytest_cache',
  // Ruby
  '.bundle',
  'log',
  // C/C++ and others
  'CMakeFiles',
]);

// Files to skip entirely.
const SKIP_FILES = new Set(['.DS_Store']);

// File extensions to skip (allowing only .svg for icons)
const DISALLOWED_EXTENSIONS = new Set([
  'png',
  'jpg',
  'jpeg',
  'gif',
  'bmp',
  'ico',
  'mp4',
  'avi',
  'mov',
  'wmv',
  'flv',
  'mp3',
  'wav',
  'webp',
]);

/**
 * Recursively builds a file tree while skipping:
 * - Unwanted directories (if not the root)
 * - Specific files (e.g. .DS_Store)
 * - Files that exceed the maximum file size.
 * - Files with disallowed media or icon extensions (only .svg files will be allowed).
 *
 * Also sorts each folder's children so that folders appear first (alphabetically) then files.
 *
 * @param dir Path of the directory
 * @param isRoot Whether this is the root folder (default true)
 */
export function getFileTree(dir: string, isRoot = true): FileNode | null {
  const baseName = path.basename(dir);

  // Possibly skip certain directories
  if (!isRoot && SKIP_DIRECTORIES.has(baseName)) {
    return null;
  }

  const tree: FileNode = { name: baseName, path: dir, children: [] };

  try {
    const items = fs.readdirSync(dir);
    tree.children = items
      .map((item) => {
        if (SKIP_FILES.has(item)) return null;
        const fullPath = path.join(dir, item);
        try {
          const stat = fs.statSync(fullPath);
          if (stat.isDirectory()) {
            return getFileTree(fullPath, false);
          }
          if (stat.size > MAX_FILE_SIZE) {
            return null;
          }
          const ext = path.extname(item).slice(1).toLowerCase();
          if (DISALLOWED_EXTENSIONS.has(ext)) {
            return null;
          }
          return { name: item, path: fullPath };
        } catch (err) {
          console.error('Error reading item:', fullPath, err);
          return null;
        }
      })
      .filter(Boolean) as FileNode[];

    tree.children.sort((a, b) => {
      const aIsFolder = !!a.children;
      const bIsFolder = !!b.children;
      if (aIsFolder && !bIsFolder) return -1;
      if (!aIsFolder && bIsFolder) return 1;
      return a.name.localeCompare(b.name);
    });
  } catch (error) {
    console.error('Error reading directory:', dir, error);
  }

  return tree;
}

export function buildFileTreeFromMapping(
  mapping: Record<
    string,
    { content: string; changeType?: 'added' | 'modified' | 'deleted' } | string
  >,
  projectPath: string,
): FileNode {
  const rootName = path.basename(projectPath);
  const root: FileNode = { name: rootName, path: projectPath, children: [] };

  for (const filePath of Object.keys(mapping)) {
    // If mapping[filePath] is a string, wrap it in an object.
    let fileData = mapping[filePath];
    if (typeof fileData === 'string') {
      fileData = { content: fileData };
      mapping[filePath] = fileData;
    }

    // Resolve the file path against the project path if it's not absolute.
    let absFilePath = filePath;
    if (!path.isAbsolute(filePath)) {
      absFilePath = path.join(projectPath, filePath);
    }

    // If no explicit changeType is given, check if the file exists on disk.
    if (!fileData.changeType) {
      if (!fs.existsSync(absFilePath)) {
        fileData.changeType = 'added';
      } else {
        fileData.changeType = 'modified';
      }
    }

    // Build the tree structure using the absolute file path.
    const rel = path.relative(projectPath, absFilePath);
    const parts = rel.split(path.sep).filter(Boolean);

    // Avoid double nesting the project folder name.
    if (parts[0] === rootName) {
      parts.shift();
    }

    let current = root;
    let accumulated = projectPath;

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      accumulated = path.join(accumulated, part);

      if (!current.children) {
        current.children = [];
      }
      let child = current.children.find((c) => c.name === part);
      if (!child) {
        child = { name: part, path: accumulated, children: [] };
        current.children.push(child);
      }
      if (i === parts.length - 1) {
        child.changeType = fileData.changeType;
      }
      current = child;
    }
  }

  return root;
}

export function mergeComparisonTrees(
  base: FileNode,
  compare: FileNode,
): FileNode {
  const merged = JSON.parse(JSON.stringify(base)) as FileNode;

  function updateOrInsert(baseNode: FileNode, compareNode: FileNode) {
    if (!compareNode.children) return;
    if (!baseNode.children) {
      baseNode.children = [];
    }

    for (const compareChild of compareNode.children) {
      const existingChild = baseNode.children.find(
        (c) => c.path === compareChild.path,
      );
      if (existingChild) {
        existingChild.changeType = compareChild.changeType ?? 'modified';
        updateOrInsert(existingChild, compareChild);
      } else {
        const newChild = JSON.parse(JSON.stringify(compareChild)) as FileNode;
        if (!newChild.changeType) {
          newChild.changeType = 'added';
        }
        baseNode.children.push(newChild);
      }
    }
  }

  updateOrInsert(merged, compare);

  return merged;
}
